<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Puzzle 最小步数求解</title>
    <link rel="stylesheet" href="8puzzle.css">
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a href="#puzzle-app">游戏</a></li>
            <li><a href="#problem-context">问题背景</a></li> 
            <li><a href="#background">算法原理</a></li>
            <li><a href="#computational-thinking">计算思维</a></li>
            <li><a href="#credits">致谢</a></li>
        </ul>
    </nav>

    <div id="puzzle-app">
        <h1>8-Puzzle</h1>

        <div id="game-board">
            <div class="tile" data-number="1">1</div>
            <div class="tile" data-number="2">2</div>
            <div class="tile" data-number="3">3</div>
            <div class="tile" data-number="4">4</div>
            <div class="tile" data-number="5">5</div>
            <div class="tile" data-number="6">6</div>
            <div class="tile" data-number="7">7</div>
            <div class="tile" data-number="8">8</div>
            <div class="tile empty" data-number="0"></div>
        </div>

        <div id="controls">
            <div class="stats">
                <p>当前步数 <span id="move-count">0</span></p>
                <p>理论最少 <span id="min-moves">?</span></p>
            </div>

            <div class="button-group">
                <button id="new-game-btn">重新开始</button>
                <button id="hint-btn">计算最优解</button>
                <button id="solve-btn">自动演示</button>
            </div>
        </div>
    </div>

    <section id="problem-context" class="content-section">
        <h2>什么是 8-Puzzle？</h2>
        <div class="text-content">
            <p><strong>8-Puzzle (八数码问题)</strong> 是一个古老而经典的滑块益智游戏。它由一个 3x3 的九宫格组成，其中包含 8 个标有数字的方块和一个空格。游戏目标是将滑块移动至从小到大依次排序的状态。<br>从某种意义上说，这可能是我接触的第一个游戏。记得在小时候，触屏手机刚出现，手机出厂会自带一个图片拼图的游戏。该游戏将一个照片平均分成9个小方格,去掉一个后再随机打乱，玩家需要通过滑动小方格复原这张图片。其实这就是一个8—puzzle。</p>
            <br>
            <h3>历史起源</h3>
            <p>这个谜题最早由 Noyes Palmer Chapman 在 1870 年代发明，后来由谜题专家 Sam Loyd 推广。在 19 世纪末，它曾引发了类似于今天“魔方热”的全民狂潮。</p>
            <br>
            <h3>8 puzzle problem 在当代的重要性</h3>
            <p>八数码问题是人工智能领域研究搜索算法、启发式优化和问题求解的重要基准问题。虽然广度优先搜索（BFS）和深度优先搜索（DFS）等算法可以解决这个问题，但A*搜索结合曼哈顿距离等有效启发式方法，能够更高效地找到最优解。理解八数码问题能够为解决人工智能领域更复杂的组合问题（例如十五数码问题）以及机器人和游戏等实际应用奠定基础。</p>
            <br>
            <h3>数学与不可解性</h3>
            <p>有趣的是，在8 puzzle problem中，只有50%的情况是可解的。 </p>
            <p>这涉及到了抽象代数中的置换群理论。基于群论的奇偶性守恒，8-Puzzle 的状态空间被分割为两个互不相通的集合，只有与目标状态同属偶置换集合，即逆序数奇偶性校验一致。这样的初始状态才是可解的。</p>
            <p>在本项目中，我们在生成新游戏时，会计算局面的逆序数。只有当逆序数为<strong>偶数</strong>时，拼图才是有解的。这也体现了计算机科学中<strong>“不可解问题”</strong>与<strong>“状态空间”</strong>的深刻原理。</p>
        </div>
    </section>

    <section id="background" class="content-section">
        <h2>算法之美</h2>
        <div class="text-content">
            <p>本程序采用 <strong>A* (A-Star) 搜索算法</strong> 寻找八数码问题的最优解。</p>
            <p>A*算法是一种启发式搜索算法，它结合了广度优先搜索（BFS）和深度优先搜索（DFS）的特点，使用优先级队列，由评估函数 f(n) 主导，优先探索最有希望的状态。</p>
            <br>
            <p><strong>核心公式：f(n) = g(n) + h(n)</strong></p>
            <p>其中，g(n) 代表从起点到当前状态的实际代价，而 h(n) 则是当前状态到目标状态的预估代价。我们使用了 <em>曼哈顿距离 (Manhattan Distance)</em> 作为启发函数，确保了搜索的高效性与结果的准确性。</p>
            <p>值得注意的是，A*算法在每个节点都会贪心的选择评估函数最小的下一个节点，但A*算法并不会像贪心算法一样错过可能的最小路径。这是因为A*算法中 openList 和 closedList 的存在。A*算法虽然优先走当下最优的路径，但会把未走过的所有可能路径都记在openList中。如果发现当前路不好走，它能随时“瞬移”回之前的任何一个路口重新开始。</p>
            <p>详细算法介绍可见：</p>
            <!-- 修复：闭合标签修正为 </a>，添加 target="_blank" -->
            <a href="https://www.geeksforgeeks.org/artificial-intelligence/8-puzzle-problem-in-ai/" target="_blank">geeksforgeeks.org/artificial-intelligence/8-puzzle-problem-in-ai/</a>
        </div>
    </section>

    <section id="computational-thinking" class="content-section">
        <h2>计算思维：重构高德纳的经典定义</h2>
        <div class="text-content">
            <p>计算机科学泰斗高德纳（Donald Knuth）在《计算机程序设计艺术》中提出了算法的五个核心特征。本项目中的 A* 算法实现，正是对这五大特征的完美演绎：</p>
            
            <div class="feature-list" style="margin-top: 30px;">
                
                <h3>有穷性 (Finiteness)</h3>
                <p><strong>理论：</strong>算法必须在有限步骤内结束。<br>
                <strong>实现：</strong>在 8-Puzzle 的状态空间图中，存在大量的环路（重复局面）。代码中引入了 <code>closedList</code>（基于 <code>Set</code> 数据结构），记录所有已访问的状态哈希值。这确保了算法绝不会在死循环中空转，配合有限的状态总数（9!/2），保证程序必然会在有限步内找到解或判定无解。</p>

                <h3>确定性 (Definiteness)</h3>
                <p><strong>理论：</strong>每一步骤必须有确切定义，无二义性。<br>
                <strong>实现：</strong>我们的启发式函数 <code>f(n) = g(n) + h(n)</code> 是绝对确定的。其中 <code>h(n)</code> 采用<strong>曼哈顿距离</strong>公式计算，对于任意给定的方块位置，其与目标位置的距离计算是唯一的。代码逻辑中没有随机猜测，每一步状态转移都由数学逻辑严格主导。</p>

                <h3>输入 (Input)</h3>
                <p><strong>理论：</strong>算法具有零个或多个输入。<br>
                <strong>实现：</strong>算法的输入是 <code>currentState</code> 数组（例如 <code>[1, 8, 2, 0, 4, 3, 7, 6, 5]</code>），它代表了棋盘的初始排列。我们在生成输入时还引入了<strong>逆序数校验</strong>，确保输入属于“可解”的数学集合。</p>

                <h3>输出 (Output)</h3>
                <p><strong>理论：</strong>算法有一个或多个与输入相关的输出。<br>
                <strong>实现：</strong>函数的输出是由 <code>reconstructPath</code> 方法生成的路径数组。它不仅仅是一个结果，而是一系列有序的操作序列，能将初始混乱的状态一步步还原为 <code>FINAL_STATE</code>。</p>

                <h3>可行性 (Effectiveness)</h3>
                <p><strong>理论：</strong>操作必须足够基础，原则上可用纸笔完成。<br>
                <strong>实现：</strong>尽管 A* 算法逻辑精妙，但其底层操作——数组元素的交换、整数的加法（计算步数）、绝对值的计算（曼哈顿距离）——都是最基础的算术与逻辑运算。计算机的高效仅在于它能以极快的速度执行这些基础操作。</p>
            </div>
            <!-- 分割线，用于视觉区分 -->
            <hr style="border: 0; border-top: 1px solid #eaeaea; margin: 40px 0;">

            <h3>贪心范式的优化：从“短视”到“全局”</h3>
            <p>在算法设计中，<strong>贪心算法 (Greedy Algorithm)</strong> 是一种直觉式的策略：每一步都选择当前看起来最好的路径。在 8-Puzzle 问题中，纯粹的贪心策略会只关注启发值 h(n)（当前状态距离目标的预估距离），即“哪一步离目标更近就走哪一步”。</p>
            
            <p>然而，这种“短视”的策略往往会陷入<strong>局部最优 (Local Optima)</strong> 的陷阱，或者虽然找到了解，但走了一条绕远路的弯路。</p>
            
            <div style="background-color: #F5F5F7; padding: 20px; border-radius: 12px; margin-top: 20px;">
                <h4 style="margin-top: 0; color: var(--text-primary); font-size: 1.1rem;">A* 算法的修正哲学</h4>
                <p style="font-size: 0.95rem; margin-bottom: 15px;">本程序所使用的 A* 算法，通过引入<strong>历史代价 g(n)</strong> 对贪心范式进行了极其优雅的修正。其核心公式体现了计算思维中的<strong>“权衡 (Trade-off)”</strong>艺术：</p>
                
                <p style="font-family: 'SF Mono', monospace; color: var(--accent-color); font-weight: 600; text-align: center; margin: 20px 0; font-size: 1.2rem;">
                    f(n) = g(n) + h(n)
                </p>

                <ul style="list-style: none; padding: 0; margin: 0;">
                    <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                        <span style="position: absolute; left: 0; color: var(--accent-color);">•</span>
                        <strong>g(n) (历史):</strong> 从起点走到当前位置已经花费的步数。它代表了“沉没成本”，提醒算法不要为了一个看起来很近的目标，而忽略了我们已经绕了多远的路。
                    </li>
                    <li style="padding-left: 20px; position: relative;">
                        <span style="position: absolute; left: 0; color: var(--accent-color);">•</span>
                        <strong>h(n) (未来):</strong> 距离目标的预估代价（曼哈顿距离）。它保留了贪心算法的“方向感”，引导搜索快速逼近目标。
                    </li>
                </ul>
            </div>

            <p style="margin-top: 20px;">
                正是因为引入了 g(n)，A* 算法拥有了<strong>可采纳性 (Admissibility)</strong>。这意味着，只要启发函数 h(n) 不高估实际距离（曼哈顿距离满足此条件），A* 算法就<strong>保证</strong>：一旦找到解，那一定是数学上的最短路径解。这是纯粹的贪心算法无法做到的。
            </p>
            <p style="margin-top: 40px; border-top: 1px solid #eaeaea; padding-top: 20px; font-style: italic;">
                "程序设计是艺术，因为它是将复杂的逻辑之美，构建在简单的基础指令之上。"
            </p>
        </div> 
    </section>

    
    <section id="credits" class="content-section" style="background-color: #F5F5F7;">
        <h2>致谢</h2>
        
        <div class="text-content" style="text-align: center; font-size: 0.9rem; color: #86868B;">
            <!-- 核心致谢：CS导论团队 -->
            <p><strong>Special Thanks</strong><br>
            <div style="margin-bottom: 40px;">
                <p style="font-size: 1.1rem; color: var(--text-primary); font-weight: 600; margin-bottom: 5px;">
                    大湾区大学计算机科学导论教学团队
                </p>
                <a href="https://www.gbu.edu.cn/menu/182" target="_blank" style="font-size: 0.9rem; color: var(--accent-color); font-weight: 500; margin-bottom: 15px; letter-spacing: 0.02em;">
                    Introduction to Computer Science Teaching Team
                </a>
                <p style="font-size: 0.95rem; line-height: 1.8; color: var(--text-secondary);">
                    感谢老师们赋予我计算思维的视角<br>本项目灵感来源于课程中用分治范式解决汉诺塔问题相关内容 <br>本项目的核心逻辑———从问题抽象到A*算法实现，都源于计科导课程的理论滋养<br>
                    从图灵机到网络思维,我在这学期的计科导课程中收获颇丰<br>
                    再次感谢徐志伟老师精心的课程设计、郑旭彬老师细致的教导
                </p>
            </div>

            <!-- 极简分割线 -->
            <div style="width: 30px; height: 2px; background-color: #d2d2d7; margin: 0 auto 40px; border-radius: 2px;"></div>
            <p><strong>Design Inspiration</strong><br>
            界面设计灵感来源于 Apple Human Interface Guidelines</p>
            
            <p style="margin-top: 15px;"><strong>Technical References</strong><br>
            核心算法参考 GeeksforGeeks 与 抽象代数置换群理论</p>

            <p style="margin-top: 15px;"><strong>Tools Used</strong><br>
            CSS interface optimized by Gemini.<br>JavaScript code framework provided by Gemini.</p>

            <div style="margin-top: 30px; border-top: 1px solid #d2d2d7; padding-top: 15px;">
                <p>&copy; 2025 [Jacob Young]. All rights reserved. 
                <a href="https://github.com/jacobyoungbu/8-puzzle-solver" target="_blank" style="margin-left: 10px; color: #0071E3;">View on GitHub</a>
                </p>
            </div>
        </div>
    </section>

    <script src="8puzzle.js"></script>
</body>
</html>